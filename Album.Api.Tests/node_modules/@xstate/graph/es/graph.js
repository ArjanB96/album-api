var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function flatten(array) {
    var _a;
    return (_a = []).concat.apply(_a, __spreadArray([], __read(array), false));
}
export function toEventObject(event) {
    if (typeof event === 'string' || typeof event === 'number') {
        return { type: event };
    }
    return event;
}
var EMPTY_MAP = {};
/**
 * Returns all state nodes of the given `node`.
 * @param stateNode State node to recursively get child state nodes from
 */
export function getStateNodes(stateNode) {
    var states = stateNode.states;
    var nodes = Object.keys(states).reduce(function (accNodes, stateKey) {
        var childStateNode = states[stateKey];
        var childStateNodes = getStateNodes(childStateNode);
        accNodes.push.apply(accNodes, __spreadArray([childStateNode], __read(childStateNodes), false));
        return accNodes;
    }, []);
    return nodes;
}
export function getChildren(stateNode) {
    if (!stateNode.states) {
        return [];
    }
    var children = Object.keys(stateNode.states).map(function (key) {
        return stateNode.states[key];
    });
    return children;
}
export function serializeState(state) {
    var value = state.value, context = state.context;
    return context === undefined
        ? JSON.stringify(value)
        : JSON.stringify(value) + ' | ' + JSON.stringify(context);
}
export function serializeEvent(event) {
    return JSON.stringify(event);
}
export function deserializeEventString(eventString) {
    return JSON.parse(eventString);
}
var defaultValueAdjMapOptions = {
    events: {},
    filter: function () { return true; },
    stateSerializer: serializeState,
    eventSerializer: serializeEvent
};
function getValueAdjMapOptions(options) {
    return __assign(__assign({}, defaultValueAdjMapOptions), options);
}
export function getAdjacencyMap(node, options) {
    var optionsWithDefaults = getValueAdjMapOptions(options);
    var filter = optionsWithDefaults.filter, stateSerializer = optionsWithDefaults.stateSerializer, eventSerializer = optionsWithDefaults.eventSerializer;
    var events = optionsWithDefaults.events;
    var adjacency = {};
    function findAdjacencies(state) {
        var e_1, _a;
        var nextEvents = state.nextEvents;
        var stateHash = stateSerializer(state);
        if (adjacency[stateHash]) {
            return;
        }
        adjacency[stateHash] = {};
        var potentialEvents = flatten(nextEvents.map(function (nextEvent) {
            var getNextEvents = events[nextEvent];
            if (!getNextEvents) {
                return [{ type: nextEvent }];
            }
            if (typeof getNextEvents === 'function') {
                return getNextEvents(state);
            }
            return getNextEvents;
        })).map(function (event) { return toEventObject(event); });
        try {
            for (var potentialEvents_1 = __values(potentialEvents), potentialEvents_1_1 = potentialEvents_1.next(); !potentialEvents_1_1.done; potentialEvents_1_1 = potentialEvents_1.next()) {
                var event_1 = potentialEvents_1_1.value;
                var nextState = void 0;
                try {
                    nextState = node.transition(state, event_1);
                }
                catch (e) {
                    throw new Error("Unable to transition from state ".concat(stateSerializer(state), " on event ").concat(eventSerializer(event_1), ": ").concat(e.message));
                }
                if ((!filter || filter(nextState)) &&
                    stateHash !== stateSerializer(nextState)) {
                    adjacency[stateHash][eventSerializer(event_1)] = {
                        state: nextState,
                        event: event_1
                    };
                    findAdjacencies(nextState);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (potentialEvents_1_1 && !potentialEvents_1_1.done && (_a = potentialEvents_1.return)) _a.call(potentialEvents_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    findAdjacencies(node.initialState);
    return adjacency;
}
export function getShortestPaths(machine, options) {
    var e_2, _a, e_3, _b;
    if (!machine.states) {
        return EMPTY_MAP;
    }
    var optionsWithDefaults = getValueAdjMapOptions(options);
    var adjacency = getAdjacencyMap(machine, optionsWithDefaults);
    // weight, state, event
    var weightMap = new Map();
    var stateMap = new Map();
    var initialVertex = optionsWithDefaults.stateSerializer(machine.initialState);
    stateMap.set(initialVertex, machine.initialState);
    weightMap.set(initialVertex, [0, undefined, undefined]);
    var unvisited = new Set();
    var visited = new Set();
    unvisited.add(initialVertex);
    while (unvisited.size > 0) {
        try {
            for (var unvisited_1 = (e_2 = void 0, __values(unvisited)), unvisited_1_1 = unvisited_1.next(); !unvisited_1_1.done; unvisited_1_1 = unvisited_1.next()) {
                var vertex = unvisited_1_1.value;
                var _c = __read(weightMap.get(vertex), 1), weight = _c[0];
                try {
                    for (var _d = (e_3 = void 0, __values(Object.keys(adjacency[vertex]))), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var event_2 = _e.value;
                        var nextSegment = adjacency[vertex][event_2];
                        var nextVertex = optionsWithDefaults.stateSerializer(nextSegment.state);
                        stateMap.set(nextVertex, nextSegment.state);
                        if (!weightMap.has(nextVertex)) {
                            weightMap.set(nextVertex, [weight + 1, vertex, event_2]);
                        }
                        else {
                            var _f = __read(weightMap.get(nextVertex), 1), nextWeight = _f[0];
                            if (nextWeight > weight + 1) {
                                weightMap.set(nextVertex, [weight + 1, vertex, event_2]);
                            }
                        }
                        if (!visited.has(nextVertex)) {
                            unvisited.add(nextVertex);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                visited.add(vertex);
                unvisited.delete(vertex);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (unvisited_1_1 && !unvisited_1_1.done && (_a = unvisited_1.return)) _a.call(unvisited_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    var statePathMap = {};
    weightMap.forEach(function (_a, stateSerial) {
        var _b = __read(_a, 3), weight = _b[0], fromState = _b[1], fromEvent = _b[2];
        var state = stateMap.get(stateSerial);
        statePathMap[stateSerial] = {
            state: state,
            paths: !fromState
                ? [
                    {
                        state: state,
                        segments: [],
                        weight: weight
                    }
                ]
                : [
                    {
                        state: state,
                        segments: statePathMap[fromState].paths[0].segments.concat({
                            state: stateMap.get(fromState),
                            event: deserializeEventString(fromEvent)
                        }),
                        weight: weight
                    }
                ]
        };
    });
    return statePathMap;
}
export function getSimplePaths(machine, options) {
    var e_4, _a;
    var optionsWithDefaults = getValueAdjMapOptions(options);
    var stateSerializer = optionsWithDefaults.stateSerializer;
    if (!machine.states) {
        return EMPTY_MAP;
    }
    // @ts-ignore - excessively deep
    var adjacency = getAdjacencyMap(machine, optionsWithDefaults);
    var stateMap = new Map();
    var visited = new Set();
    var path = [];
    var paths = {};
    function util(fromState, toStateSerial) {
        var e_5, _a;
        var fromStateSerial = stateSerializer(fromState);
        visited.add(fromStateSerial);
        if (fromStateSerial === toStateSerial) {
            if (!paths[toStateSerial]) {
                paths[toStateSerial] = {
                    state: stateMap.get(toStateSerial),
                    paths: []
                };
            }
            paths[toStateSerial].paths.push({
                state: fromState,
                weight: path.length,
                segments: __spreadArray([], __read(path), false)
            });
        }
        else {
            try {
                for (var _b = __values(Object.keys(adjacency[fromStateSerial])), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var subEvent = _c.value;
                    var nextSegment = adjacency[fromStateSerial][subEvent];
                    if (!nextSegment) {
                        continue;
                    }
                    var nextStateSerial = stateSerializer(nextSegment.state);
                    stateMap.set(nextStateSerial, nextSegment.state);
                    if (!visited.has(nextStateSerial)) {
                        path.push({
                            state: stateMap.get(fromStateSerial),
                            event: deserializeEventString(subEvent)
                        });
                        util(nextSegment.state, toStateSerial);
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        path.pop();
        visited.delete(fromStateSerial);
    }
    var initialStateSerial = stateSerializer(machine.initialState);
    stateMap.set(initialStateSerial, machine.initialState);
    try {
        for (var _b = __values(Object.keys(adjacency)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var nextStateSerial = _c.value;
            util(machine.initialState, nextStateSerial);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return paths;
}
export function getSimplePathsAsArray(machine, options) {
    var result = getSimplePaths(machine, options);
    return Object.keys(result).map(function (key) { return result[key]; });
}
export function toDirectedGraph(stateNode) {
    var edges = flatten(stateNode.transitions.map(function (t, transitionIndex) {
        var targets = t.target ? t.target : [stateNode];
        return targets.map(function (target, targetIndex) {
            var edge = {
                id: "".concat(stateNode.id, ":").concat(transitionIndex, ":").concat(targetIndex),
                source: stateNode,
                target: target,
                transition: t,
                label: {
                    text: t.eventType,
                    toJSON: function () { return ({ text: t.eventType }); }
                },
                toJSON: function () {
                    var label = edge.label;
                    return { source: stateNode.id, target: target.id, label: label };
                }
            };
            return edge;
        });
    }));
    var graph = {
        id: stateNode.id,
        stateNode: stateNode,
        children: getChildren(stateNode).map(toDirectedGraph),
        edges: edges,
        toJSON: function () {
            var id = graph.id, children = graph.children, graphEdges = graph.edges;
            return { id: id, children: children, edges: graphEdges };
        }
    };
    return graph;
}
export function getPathFromEvents(machine, events) {
    var e_6, _a;
    var optionsWithDefaults = getValueAdjMapOptions({
        events: events.reduce(function (events, event) {
            var _a;
            var _b;
            (_a = events[_b = event.type]) !== null && _a !== void 0 ? _a : (events[_b] = []);
            events[event.type].push(event);
            return events;
        }, {})
    });
    var stateSerializer = optionsWithDefaults.stateSerializer, eventSerializer = optionsWithDefaults.eventSerializer;
    if (!machine.states) {
        return {
            state: machine.initialState,
            segments: [],
            weight: 0
        };
    }
    var adjacency = getAdjacencyMap(machine, optionsWithDefaults);
    var stateMap = new Map();
    var path = [];
    var initialStateSerial = stateSerializer(machine.initialState);
    stateMap.set(initialStateSerial, machine.initialState);
    var stateSerial = initialStateSerial;
    var state = machine.initialState;
    try {
        for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
            var event_3 = events_1_1.value;
            path.push({
                state: stateMap.get(stateSerial),
                event: event_3
            });
            var eventSerial = eventSerializer(event_3);
            var nextSegment = adjacency[stateSerial][eventSerial];
            if (!nextSegment) {
                throw new Error("Invalid transition from ".concat(stateSerial, " with ").concat(eventSerial));
            }
            var nextStateSerial = stateSerializer(nextSegment.state);
            stateMap.set(nextStateSerial, nextSegment.state);
            stateSerial = nextStateSerial;
            state = nextSegment.state;
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return {
        state: state,
        segments: path,
        weight: path.length
    };
}
